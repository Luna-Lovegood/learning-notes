/**
 * C程序中的数组 数组应用练习 编程题 #6：循环移动
 *
 * @file: CircularShift.cpp
 * @description: 给定一组整数，要求利用数组把这组数保存起来，再利用实现对数组中的数循环移动。假定共有n个整数，则要使前面各数顺序向后移m个
                位置，并使最后m各数变为最前面的m各数。注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也不要用两个数组的方式实现。
                要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。
 * @input: 输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。
 * @output: 输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。
 * 样例输入
    11 4
    15 3 76 67 84 87 13 67 45 34 45
 * 样例输出
    67 45 34 45 15 3 76 67 84 87 13
 * @hint: 这是一道经典的算法问题，在企业面试里出现概率很高。除了循环m次每次移动一个数以外（这样需要对数组操作m*n次），你还能想到更高效的算法
        吗（只用操作3*n次）？依然要求不使用额外数组，在原数组上移位之后顺序输出。
 *
 * @author: Du Ang
 * @date: Apr. 7th, 2017
 */

#include <iostream>

using namespace std;

int findGCD(int a, int b);  // 自定义函数，求a和b的最大公约数

int main(int argc, char *argv[])
{
    int n = 0, m = 0;   // n个正整数，循环右移m位
    int temp1 = 0, temp2 = 0;   // 临时变量，用于临时存放移位的数
    cin >> n >> m;
    int a[n] = {0};     // 数组a[]存储输入的n个正整数，全部初始化为0
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    m = m % n;  // 因为是循环右移，所以要避免循环移位一圈以上的情况
    /* 我的算法是，先把第一个的数提出来给temp，然后去它前面找第m个数（也就是应该移到这个位置数）移到这里，以此类推，溯源而上。
       问题是：1.这样最终能完成所有数的移位吗？ 2.什么时候完成遍历呢？
       关于1，经过观察，我发现如果n和m互质，则能够遍历所有的数组；如果不互质，则不能完成遍历。n和m不互质时，设gcd为n和m的最大公约数，分别
       前gcd个数作为起点，经过gcd次“溯源而上”才能完成遍历。由于n，m互质即n和m的最大公约数为1，所以综合起来看，总共需要遍历gcd个分支就可
       以完成整个数组所有分支的遍历。以上只是我根据观察结果做出的猜想，未证明。
       关于2，可以设置一个标志位origin，如果“回溯”到这个origin，则完成了这一个分支的遍历。
    */
    int gcd = findGCD(n, m);    // 首先求出n和m的最大公约数gcd
    for (int i = 0; i < gcd; i++) {
        int origin = i;     // 起点
        int temp = a[i];    // 将起点位置的数存放于temp中
        do {
            if (i - m < 0) {
                if ((i-m+n) == origin) {
                    a[i] = temp;        // 已经回到起点，完成遍历
                } else {
                    a[i] = a[i-m+n];    // 回到数组尾
                }
                i = i - m + n;
            } else {
                if ((i-m) == origin) {
                    a[i] = temp;        // 已经回到起点，完成遍历
                } else {
                    a[i] = a[i-m];
                }
                i = i - m;
            }
        } while (i != origin);
    }
    for (int i = 0; i < n; i++) {
        cout << a[i] << " ";    // 打印数组
    }
    cout << endl;

    return 0;
}

// 实现函数findGCD()，求两个数的最大公约数
// Copied from ../4/SumFractionImprove.cpp
int findGCD(int a, int b)
{
    // 求最大公约数，这里用的是欧几里得法
    int c;
    while (a != 0) {
        c = a; a = b%a; b = c;
    }
    return b;
}
